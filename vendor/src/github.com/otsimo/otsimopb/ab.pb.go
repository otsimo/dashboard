// Code generated by protoc-gen-gogo.
// source: ab.proto
// DO NOT EDIT!

/*
	Package otsimopb is a generated protocol buffer package.

	It is generated from these files:
		ab.proto
		analysis.proto
		api.proto
		catalog.proto
		content.proto
		dashboard.proto
		dashprovider.proto
		datasetmodels.proto
		discovery.proto
		file.proto
		listener.proto
		messages.proto
		models.proto
		registry.proto
		search.proto
		simplyanalysis.proto
		watch.proto

	It has these top-level messages:
		ABTestGroup
		ABDisableReq
		ListTestGroupReq
		AppTestingStatus
		CheckUserStatusReq
		ChangeUserTestGroupReq
		UserTestGroupStatus
		TimeRange
		ChildAndProfileIds
		ChildAndTimeRange
		GameWithVersions
		PlayedGamesList
		QuerySort
		Aggregation
		GroupInterval
		QueryGroup
		Query
		AnalyzeRequest
		AnalyzeResult
		ActiveUsersRequest
		ActiveUsersResult
		RetentionRequest
		RetentionResult
		InactiveUsersRequest
		GetActiveUsersRequest
		ActiveOnRangeRequest
		GameInfoResponse
		AppDataInfoReq
		StatisticsReq
		StatisticsRes
		CatalogItem
		Catalog
		CatalogPullRequest
		CatalogListRequest
		CatalogListResponse
		CatalogApproveRequest
		Content
		ContentListRequest
		ContentListResponse
		ContentGetRequest
		DashboardItems
		DashboardGetRequest
		CardDecoration
		CardEmpty
		CardWebpage
		CardApplink
		CardAnalysis
		Card
		ProviderGetRequest
		ProviderItem
		ProviderItems
		ProviderInfoRequest
		ProviderInfo
		Column
		TimeOfDay
		RowValue
		Row
		DataSet
		OtsimoServices
		DiscoveryRequest
		SelfLearningSegment
		SelfLearningConfig
		FileMetadata
		UploadReq
		UploadRes
		StoreReq
		StoreRes
		LookupReq
		LookupRes
		DeviceInfo
		GameInfo
		Point
		Vector3
		MotionData
		GestureData
		Event
		AppEventData
		BatchEventData
		BatchEvent
		EventResponse
		GetProfileRequest
		GetChildRequest
		GetChildrenFromProfileRequest
		ChangeChildActivationRequest
		GetChildrenFromProfileResponse
		GetGameReleaseRequest
		SoundEnableRequest
		GameEntryRequest
		PublishResponse
		ValidateRequest
		UpdateIndecesRequest
		GetGameRequest
		ListGamesRequest
		ListItem
		ListItemWithTests
		GetLatestVersionsRequest
		GameAndVersion
		GameVersionsResponse
		IndexRequest
		SearchResult
		SearchRequest
		SearchResponse
		Response
		LabelSelectorRequirement
		LabelSelectorTerm
		LabelSelector
		Address
		Profile
		ChildGameEntry
		Child
		Author
		GameMetadata
		GameManifest
		Game
		GameRelease
		UploadToken
		AllGameReleases
		GameCategoryLocale
		GameCategory
		CategoryReq
		CategoryListReq
		CategoryList
		GamePlayingRequest
		GamePlayingReply
		EmitRequest
		EmitResponse
		WatchRequest
		WatchEvent
		WatchResponse
*/
package otsimopb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ABTestGroup struct {
	Name   string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	AppId  string `protobuf:"bytes,2,opt,name=app_id,json=appId,proto3" json:"app_id,omitempty"`
	Weight int32  `protobuf:"varint,3,opt,name=weight,proto3" json:"weight,omitempty"`
	Active bool   `protobuf:"varint,4,opt,name=active,proto3" json:"active,omitempty"`
}

func (m *ABTestGroup) Reset()                    { *m = ABTestGroup{} }
func (m *ABTestGroup) String() string            { return proto.CompactTextString(m) }
func (*ABTestGroup) ProtoMessage()               {}
func (*ABTestGroup) Descriptor() ([]byte, []int) { return fileDescriptorAb, []int{0} }

type ABDisableReq struct {
	Name  string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	AppId string `protobuf:"bytes,2,opt,name=app_id,json=appId,proto3" json:"app_id,omitempty"`
}

func (m *ABDisableReq) Reset()                    { *m = ABDisableReq{} }
func (m *ABDisableReq) String() string            { return proto.CompactTextString(m) }
func (*ABDisableReq) ProtoMessage()               {}
func (*ABDisableReq) Descriptor() ([]byte, []int) { return fileDescriptorAb, []int{1} }

type ListTestGroupReq struct {
	AppId string `protobuf:"bytes,1,opt,name=app_id,json=appId,proto3" json:"app_id,omitempty"`
}

func (m *ListTestGroupReq) Reset()                    { *m = ListTestGroupReq{} }
func (m *ListTestGroupReq) String() string            { return proto.CompactTextString(m) }
func (*ListTestGroupReq) ProtoMessage()               {}
func (*ListTestGroupReq) Descriptor() ([]byte, []int) { return fileDescriptorAb, []int{2} }

type AppTestingStatus struct {
	Version int32          `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	Tests   []*ABTestGroup `protobuf:"bytes,2,rep,name=tests" json:"tests,omitempty"`
}

func (m *AppTestingStatus) Reset()                    { *m = AppTestingStatus{} }
func (m *AppTestingStatus) String() string            { return proto.CompactTextString(m) }
func (*AppTestingStatus) ProtoMessage()               {}
func (*AppTestingStatus) Descriptor() ([]byte, []int) { return fileDescriptorAb, []int{3} }

type CheckUserStatusReq struct {
	UserId string `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (m *CheckUserStatusReq) Reset()                    { *m = CheckUserStatusReq{} }
func (m *CheckUserStatusReq) String() string            { return proto.CompactTextString(m) }
func (*CheckUserStatusReq) ProtoMessage()               {}
func (*CheckUserStatusReq) Descriptor() ([]byte, []int) { return fileDescriptorAb, []int{4} }

type ChangeUserTestGroupReq struct {
	UserId string `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	AppId  string `protobuf:"bytes,3,opt,name=app_id,json=appId,proto3" json:"app_id,omitempty"`
	// TestGroupName is empty for no testing group
	TestGroupName string `protobuf:"bytes,4,opt,name=test_group_name,json=testGroupName,proto3" json:"test_group_name,omitempty"`
}

func (m *ChangeUserTestGroupReq) Reset()                    { *m = ChangeUserTestGroupReq{} }
func (m *ChangeUserTestGroupReq) String() string            { return proto.CompactTextString(m) }
func (*ChangeUserTestGroupReq) ProtoMessage()               {}
func (*ChangeUserTestGroupReq) Descriptor() ([]byte, []int) { return fileDescriptorAb, []int{5} }

type UserTestGroupStatus struct {
	UserId string                          `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Apps   []*UserTestGroupStatus_AppGroup `protobuf:"bytes,2,rep,name=apps" json:"apps,omitempty"`
}

func (m *UserTestGroupStatus) Reset()                    { *m = UserTestGroupStatus{} }
func (m *UserTestGroupStatus) String() string            { return proto.CompactTextString(m) }
func (*UserTestGroupStatus) ProtoMessage()               {}
func (*UserTestGroupStatus) Descriptor() ([]byte, []int) { return fileDescriptorAb, []int{6} }

type UserTestGroupStatus_AppGroup struct {
	AppId     string `protobuf:"bytes,1,opt,name=app_id,json=appId,proto3" json:"app_id,omitempty"`
	TestGroup string `protobuf:"bytes,2,opt,name=test_group,json=testGroup,proto3" json:"test_group,omitempty"`
	Version   int32  `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *UserTestGroupStatus_AppGroup) Reset()         { *m = UserTestGroupStatus_AppGroup{} }
func (m *UserTestGroupStatus_AppGroup) String() string { return proto.CompactTextString(m) }
func (*UserTestGroupStatus_AppGroup) ProtoMessage()    {}
func (*UserTestGroupStatus_AppGroup) Descriptor() ([]byte, []int) {
	return fileDescriptorAb, []int{6, 0}
}

func init() {
	proto.RegisterType((*ABTestGroup)(nil), "otsimo.abtest.ABTestGroup")
	proto.RegisterType((*ABDisableReq)(nil), "otsimo.abtest.ABDisableReq")
	proto.RegisterType((*ListTestGroupReq)(nil), "otsimo.abtest.ListTestGroupReq")
	proto.RegisterType((*AppTestingStatus)(nil), "otsimo.abtest.AppTestingStatus")
	proto.RegisterType((*CheckUserStatusReq)(nil), "otsimo.abtest.CheckUserStatusReq")
	proto.RegisterType((*ChangeUserTestGroupReq)(nil), "otsimo.abtest.ChangeUserTestGroupReq")
	proto.RegisterType((*UserTestGroupStatus)(nil), "otsimo.abtest.UserTestGroupStatus")
	proto.RegisterType((*UserTestGroupStatus_AppGroup)(nil), "otsimo.abtest.UserTestGroupStatus.AppGroup")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ABTest service

type ABTestClient interface {
	// CreateTestGroup
	CreateTestGroup(ctx context.Context, in *ABTestGroup, opts ...grpc.CallOption) (*AppTestingStatus, error)
	// DisableTestGroup
	DisableTestGroup(ctx context.Context, in *ABDisableReq, opts ...grpc.CallOption) (*AppTestingStatus, error)
	// ListTestGroupsForApp
	ListTestGroupsForApp(ctx context.Context, in *ListTestGroupReq, opts ...grpc.CallOption) (*AppTestingStatus, error)
	CheckUserStatus(ctx context.Context, in *CheckUserStatusReq, opts ...grpc.CallOption) (*UserTestGroupStatus, error)
	ChangeUserTestGroup(ctx context.Context, in *ChangeUserTestGroupReq, opts ...grpc.CallOption) (*UserTestGroupStatus, error)
}

type aBTestClient struct {
	cc *grpc.ClientConn
}

func NewABTestClient(cc *grpc.ClientConn) ABTestClient {
	return &aBTestClient{cc}
}

func (c *aBTestClient) CreateTestGroup(ctx context.Context, in *ABTestGroup, opts ...grpc.CallOption) (*AppTestingStatus, error) {
	out := new(AppTestingStatus)
	err := grpc.Invoke(ctx, "/otsimo.abtest.ABTest/CreateTestGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aBTestClient) DisableTestGroup(ctx context.Context, in *ABDisableReq, opts ...grpc.CallOption) (*AppTestingStatus, error) {
	out := new(AppTestingStatus)
	err := grpc.Invoke(ctx, "/otsimo.abtest.ABTest/DisableTestGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aBTestClient) ListTestGroupsForApp(ctx context.Context, in *ListTestGroupReq, opts ...grpc.CallOption) (*AppTestingStatus, error) {
	out := new(AppTestingStatus)
	err := grpc.Invoke(ctx, "/otsimo.abtest.ABTest/ListTestGroupsForApp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aBTestClient) CheckUserStatus(ctx context.Context, in *CheckUserStatusReq, opts ...grpc.CallOption) (*UserTestGroupStatus, error) {
	out := new(UserTestGroupStatus)
	err := grpc.Invoke(ctx, "/otsimo.abtest.ABTest/CheckUserStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aBTestClient) ChangeUserTestGroup(ctx context.Context, in *ChangeUserTestGroupReq, opts ...grpc.CallOption) (*UserTestGroupStatus, error) {
	out := new(UserTestGroupStatus)
	err := grpc.Invoke(ctx, "/otsimo.abtest.ABTest/ChangeUserTestGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ABTest service

type ABTestServer interface {
	// CreateTestGroup
	CreateTestGroup(context.Context, *ABTestGroup) (*AppTestingStatus, error)
	// DisableTestGroup
	DisableTestGroup(context.Context, *ABDisableReq) (*AppTestingStatus, error)
	// ListTestGroupsForApp
	ListTestGroupsForApp(context.Context, *ListTestGroupReq) (*AppTestingStatus, error)
	CheckUserStatus(context.Context, *CheckUserStatusReq) (*UserTestGroupStatus, error)
	ChangeUserTestGroup(context.Context, *ChangeUserTestGroupReq) (*UserTestGroupStatus, error)
}

func RegisterABTestServer(s *grpc.Server, srv ABTestServer) {
	s.RegisterService(&_ABTest_serviceDesc, srv)
}

func _ABTest_CreateTestGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ABTestGroup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ABTestServer).CreateTestGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/otsimo.abtest.ABTest/CreateTestGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ABTestServer).CreateTestGroup(ctx, req.(*ABTestGroup))
	}
	return interceptor(ctx, in, info, handler)
}

func _ABTest_DisableTestGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ABDisableReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ABTestServer).DisableTestGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/otsimo.abtest.ABTest/DisableTestGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ABTestServer).DisableTestGroup(ctx, req.(*ABDisableReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ABTest_ListTestGroupsForApp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTestGroupReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ABTestServer).ListTestGroupsForApp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/otsimo.abtest.ABTest/ListTestGroupsForApp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ABTestServer).ListTestGroupsForApp(ctx, req.(*ListTestGroupReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ABTest_CheckUserStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckUserStatusReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ABTestServer).CheckUserStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/otsimo.abtest.ABTest/CheckUserStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ABTestServer).CheckUserStatus(ctx, req.(*CheckUserStatusReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ABTest_ChangeUserTestGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangeUserTestGroupReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ABTestServer).ChangeUserTestGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/otsimo.abtest.ABTest/ChangeUserTestGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ABTestServer).ChangeUserTestGroup(ctx, req.(*ChangeUserTestGroupReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _ABTest_serviceDesc = grpc.ServiceDesc{
	ServiceName: "otsimo.abtest.ABTest",
	HandlerType: (*ABTestServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateTestGroup",
			Handler:    _ABTest_CreateTestGroup_Handler,
		},
		{
			MethodName: "DisableTestGroup",
			Handler:    _ABTest_DisableTestGroup_Handler,
		},
		{
			MethodName: "ListTestGroupsForApp",
			Handler:    _ABTest_ListTestGroupsForApp_Handler,
		},
		{
			MethodName: "CheckUserStatus",
			Handler:    _ABTest_CheckUserStatus_Handler,
		},
		{
			MethodName: "ChangeUserTestGroup",
			Handler:    _ABTest_ChangeUserTestGroup_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ab.proto",
}

func (m *ABTestGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ABTestGroup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAb(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.AppId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAb(dAtA, i, uint64(len(m.AppId)))
		i += copy(dAtA[i:], m.AppId)
	}
	if m.Weight != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAb(dAtA, i, uint64(m.Weight))
	}
	if m.Active {
		dAtA[i] = 0x20
		i++
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ABDisableReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ABDisableReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAb(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.AppId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAb(dAtA, i, uint64(len(m.AppId)))
		i += copy(dAtA[i:], m.AppId)
	}
	return i, nil
}

func (m *ListTestGroupReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListTestGroupReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AppId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAb(dAtA, i, uint64(len(m.AppId)))
		i += copy(dAtA[i:], m.AppId)
	}
	return i, nil
}

func (m *AppTestingStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppTestingStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAb(dAtA, i, uint64(m.Version))
	}
	if len(m.Tests) > 0 {
		for _, msg := range m.Tests {
			dAtA[i] = 0x12
			i++
			i = encodeVarintAb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CheckUserStatusReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckUserStatusReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAb(dAtA, i, uint64(len(m.UserId)))
		i += copy(dAtA[i:], m.UserId)
	}
	return i, nil
}

func (m *ChangeUserTestGroupReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangeUserTestGroupReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAb(dAtA, i, uint64(len(m.UserId)))
		i += copy(dAtA[i:], m.UserId)
	}
	if len(m.AppId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAb(dAtA, i, uint64(len(m.AppId)))
		i += copy(dAtA[i:], m.AppId)
	}
	if len(m.TestGroupName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAb(dAtA, i, uint64(len(m.TestGroupName)))
		i += copy(dAtA[i:], m.TestGroupName)
	}
	return i, nil
}

func (m *UserTestGroupStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserTestGroupStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAb(dAtA, i, uint64(len(m.UserId)))
		i += copy(dAtA[i:], m.UserId)
	}
	if len(m.Apps) > 0 {
		for _, msg := range m.Apps {
			dAtA[i] = 0x12
			i++
			i = encodeVarintAb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UserTestGroupStatus_AppGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserTestGroupStatus_AppGroup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AppId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAb(dAtA, i, uint64(len(m.AppId)))
		i += copy(dAtA[i:], m.AppId)
	}
	if len(m.TestGroup) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAb(dAtA, i, uint64(len(m.TestGroup)))
		i += copy(dAtA[i:], m.TestGroup)
	}
	if m.Version != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAb(dAtA, i, uint64(m.Version))
	}
	return i, nil
}

func encodeFixed64Ab(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Ab(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintAb(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ABTestGroup) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAb(uint64(l))
	}
	l = len(m.AppId)
	if l > 0 {
		n += 1 + l + sovAb(uint64(l))
	}
	if m.Weight != 0 {
		n += 1 + sovAb(uint64(m.Weight))
	}
	if m.Active {
		n += 2
	}
	return n
}

func (m *ABDisableReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAb(uint64(l))
	}
	l = len(m.AppId)
	if l > 0 {
		n += 1 + l + sovAb(uint64(l))
	}
	return n
}

func (m *ListTestGroupReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.AppId)
	if l > 0 {
		n += 1 + l + sovAb(uint64(l))
	}
	return n
}

func (m *AppTestingStatus) Size() (n int) {
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovAb(uint64(m.Version))
	}
	if len(m.Tests) > 0 {
		for _, e := range m.Tests {
			l = e.Size()
			n += 1 + l + sovAb(uint64(l))
		}
	}
	return n
}

func (m *CheckUserStatusReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.UserId)
	if l > 0 {
		n += 1 + l + sovAb(uint64(l))
	}
	return n
}

func (m *ChangeUserTestGroupReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.UserId)
	if l > 0 {
		n += 1 + l + sovAb(uint64(l))
	}
	l = len(m.AppId)
	if l > 0 {
		n += 1 + l + sovAb(uint64(l))
	}
	l = len(m.TestGroupName)
	if l > 0 {
		n += 1 + l + sovAb(uint64(l))
	}
	return n
}

func (m *UserTestGroupStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.UserId)
	if l > 0 {
		n += 1 + l + sovAb(uint64(l))
	}
	if len(m.Apps) > 0 {
		for _, e := range m.Apps {
			l = e.Size()
			n += 1 + l + sovAb(uint64(l))
		}
	}
	return n
}

func (m *UserTestGroupStatus_AppGroup) Size() (n int) {
	var l int
	_ = l
	l = len(m.AppId)
	if l > 0 {
		n += 1 + l + sovAb(uint64(l))
	}
	l = len(m.TestGroup)
	if l > 0 {
		n += 1 + l + sovAb(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovAb(uint64(m.Version))
	}
	return n
}

func sovAb(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAb(x uint64) (n int) {
	return sovAb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ABTestGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ABTestGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ABTestGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			m.Weight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ABDisableReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ABDisableReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ABDisableReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListTestGroupReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListTestGroupReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListTestGroupReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppTestingStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppTestingStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppTestingStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tests = append(m.Tests, &ABTestGroup{})
			if err := m.Tests[len(m.Tests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckUserStatusReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckUserStatusReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckUserStatusReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangeUserTestGroupReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangeUserTestGroupReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangeUserTestGroupReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestGroupName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestGroupName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserTestGroupStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserTestGroupStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserTestGroupStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Apps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Apps = append(m.Apps, &UserTestGroupStatus_AppGroup{})
			if err := m.Apps[len(m.Apps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserTestGroupStatus_AppGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAb   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ab.proto", fileDescriptorAb) }

var fileDescriptorAb = []byte{
	// 529 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x54, 0x5d, 0x6f, 0xd3, 0x30,
	0x14, 0x9d, 0x9b, 0xb6, 0xeb, 0xee, 0x98, 0x5a, 0x79, 0x30, 0xa2, 0x22, 0x4a, 0x89, 0x04, 0x2a,
	0x42, 0xcb, 0xd0, 0x78, 0x40, 0x3c, 0xa1, 0xb6, 0x08, 0x34, 0x09, 0x8d, 0x29, 0x1b, 0x12, 0xda,
	0x03, 0xc5, 0x49, 0x4d, 0x12, 0x41, 0x6a, 0x13, 0x3b, 0xe3, 0xaf, 0xf0, 0xcc, 0x2f, 0xe1, 0x71,
	0x12, 0x2f, 0xfc, 0x04, 0x28, 0x7f, 0x04, 0xc5, 0x49, 0x96, 0x8f, 0xb6, 0x6c, 0xbc, 0xe5, 0xda,
	0xf7, 0x9e, 0x7b, 0x7c, 0xce, 0x51, 0xa0, 0x45, 0x6c, 0x93, 0x87, 0x4c, 0x32, 0xbc, 0xc5, 0xa4,
	0xf0, 0x03, 0x66, 0x12, 0x5b, 0x52, 0x21, 0xbb, 0xbb, 0xae, 0x2f, 0xbd, 0xc8, 0x36, 0x1d, 0x16,
	0xec, 0xb9, 0xcc, 0x65, 0x7b, 0xaa, 0xcb, 0x8e, 0x3e, 0xa8, 0x4a, 0x15, 0xea, 0x2b, 0x99, 0x36,
	0x3c, 0xd8, 0x1c, 0x8e, 0x4e, 0xa8, 0x90, 0x2f, 0x43, 0x16, 0x71, 0x8c, 0xa1, 0x3e, 0x23, 0x01,
	0xd5, 0x51, 0x1f, 0x0d, 0x36, 0x2c, 0xf5, 0x8d, 0x6f, 0x40, 0x93, 0x70, 0x3e, 0xf1, 0xa7, 0x7a,
	0x4d, 0x9d, 0x36, 0x08, 0xe7, 0x07, 0x53, 0xbc, 0x03, 0xcd, 0x2f, 0xd4, 0x77, 0x3d, 0xa9, 0x6b,
	0x7d, 0x34, 0x68, 0x58, 0x69, 0x15, 0x9f, 0x13, 0x47, 0xfa, 0x67, 0x54, 0xaf, 0xf7, 0xd1, 0xa0,
	0x65, 0xa5, 0x95, 0xf1, 0x14, 0xae, 0x0d, 0x47, 0xcf, 0x7d, 0x41, 0xec, 0x4f, 0xd4, 0xa2, 0x9f,
	0xff, 0x63, 0x95, 0xf1, 0x00, 0x3a, 0xaf, 0x7c, 0x21, 0x2f, 0x68, 0xc6, 0xe3, 0x79, 0x2b, 0x2a,
	0xb6, 0xbe, 0x83, 0xce, 0x90, 0xf3, 0xb8, 0xd3, 0x9f, 0xb9, 0xc7, 0x92, 0xc8, 0x48, 0x60, 0x1d,
	0xd6, 0xcf, 0x68, 0x28, 0x7c, 0x36, 0x53, 0xbd, 0x0d, 0x2b, 0x2b, 0xf1, 0x23, 0x68, 0xc4, 0xa2,
	0x09, 0xbd, 0xd6, 0xd7, 0x06, 0x9b, 0xfb, 0x5d, 0xb3, 0xa4, 0xa5, 0x59, 0x50, 0xc6, 0x4a, 0x1a,
	0x8d, 0x5d, 0xc0, 0x63, 0x8f, 0x3a, 0x1f, 0xdf, 0x08, 0x1a, 0x26, 0xf0, 0x31, 0x99, 0x9b, 0xb0,
	0x1e, 0x09, 0x1a, 0xe6, 0x6c, 0x9a, 0x71, 0x79, 0x30, 0x35, 0x38, 0xec, 0x8c, 0x3d, 0x32, 0x73,
	0x69, 0xdc, 0x5f, 0xe2, 0xbf, 0x6a, 0xa4, 0xf0, 0x30, 0xad, 0x28, 0xf7, 0x7d, 0x68, 0xc7, 0x0c,
	0x26, 0x6e, 0x0c, 0x30, 0x51, 0xca, 0xd5, 0xd5, 0xfd, 0x96, 0xcc, 0x60, 0x0f, 0x49, 0x40, 0x8d,
	0x1f, 0x08, 0xb6, 0x4b, 0xcb, 0x52, 0x11, 0x56, 0xee, 0x7b, 0x06, 0x75, 0xc2, 0x79, 0x26, 0xc1,
	0xc3, 0x8a, 0x04, 0x4b, 0xa0, 0xcc, 0x21, 0xe7, 0xc9, 0x33, 0xd4, 0x60, 0xf7, 0x14, 0x5a, 0xd9,
	0xc9, 0x0a, 0x57, 0xf0, 0x6d, 0x80, 0x9c, 0x7c, 0xea, 0xed, 0xc6, 0x05, 0xef, 0xa2, 0x41, 0x5a,
	0xc9, 0xa0, 0xfd, 0xef, 0x1a, 0x34, 0x13, 0x17, 0xf0, 0x21, 0xb4, 0xc7, 0x21, 0x25, 0x92, 0xe6,
	0x69, 0xfd, 0x87, 0x5f, 0xdd, 0x3b, 0xd5, 0xbb, 0x6a, 0x2a, 0x8e, 0xa0, 0x93, 0xa6, 0x31, 0x07,
	0xbc, 0xb5, 0x00, 0x98, 0x07, 0xf6, 0x72, 0xc4, 0xb7, 0x70, 0xbd, 0x14, 0x53, 0xf1, 0x82, 0x85,
	0x43, 0xce, 0x71, 0x75, 0xb0, 0x9a, 0xe5, 0xab, 0x20, 0xb7, 0x2b, 0xa9, 0xc3, 0x77, 0x2b, 0x33,
	0x8b, 0xa9, 0xec, 0x1a, 0x97, 0x7b, 0x89, 0xdf, 0xc3, 0xf6, 0x92, 0x80, 0xe2, 0x7b, 0x0b, 0xe8,
	0xcb, 0x42, 0x7c, 0x95, 0x0d, 0xa3, 0x27, 0xe7, 0xbf, 0x7b, 0x6b, 0xe7, 0xf3, 0x1e, 0xfa, 0x39,
	0xef, 0xa1, 0x5f, 0xf3, 0x1e, 0xfa, 0xfa, 0xa7, 0xb7, 0x06, 0x6d, 0x87, 0x05, 0xd9, 0xb0, 0x1b,
	0x72, 0xe7, 0x08, 0x9d, 0xb6, 0x92, 0x92, 0xdb, 0xdf, 0x6a, 0xda, 0xeb, 0x93, 0x63, 0xbb, 0xa9,
	0xfe, 0x50, 0x8f, 0xff, 0x06, 0x00, 0x00, 0xff, 0xff, 0xb0, 0x6f, 0x5d, 0x2a, 0xeb, 0x04, 0x00,
	0x00,
}
