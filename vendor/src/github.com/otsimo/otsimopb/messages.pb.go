// Code generated by protoc-gen-gogo.
// source: messages.proto
// DO NOT EDIT!

package otsimopb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type RequestReleaseState int32

const (
	RequestReleaseState_PRODUCTION_STATE RequestReleaseState = 0
	RequestReleaseState_ALL_STATES       RequestReleaseState = 1
)

var RequestReleaseState_name = map[int32]string{
	0: "PRODUCTION_STATE",
	1: "ALL_STATES",
}
var RequestReleaseState_value = map[string]int32{
	"PRODUCTION_STATE": 0,
	"ALL_STATES":       1,
}

func (x RequestReleaseState) String() string {
	return proto.EnumName(RequestReleaseState_name, int32(x))
}
func (RequestReleaseState) EnumDescriptor() ([]byte, []int) { return fileDescriptorMessages, []int{0} }

// A label selector operator is the set of operators that can be used in
// a label selector requirement.
type LabelSelectorOperator int32

const (
	LabelSelectorOperator_In           LabelSelectorOperator = 0
	LabelSelectorOperator_NotIn        LabelSelectorOperator = 1
	LabelSelectorOperator_Exists       LabelSelectorOperator = 2
	LabelSelectorOperator_DoesNotExist LabelSelectorOperator = 3
	LabelSelectorOperator_Gt           LabelSelectorOperator = 4
	LabelSelectorOperator_Lt           LabelSelectorOperator = 5
)

var LabelSelectorOperator_name = map[int32]string{
	0: "In",
	1: "NotIn",
	2: "Exists",
	3: "DoesNotExist",
	4: "Gt",
	5: "Lt",
}
var LabelSelectorOperator_value = map[string]int32{
	"In":           0,
	"NotIn":        1,
	"Exists":       2,
	"DoesNotExist": 3,
	"Gt":           4,
	"Lt":           5,
}

func (x LabelSelectorOperator) String() string {
	return proto.EnumName(LabelSelectorOperator_name, int32(x))
}
func (LabelSelectorOperator) EnumDescriptor() ([]byte, []int) { return fileDescriptorMessages, []int{1} }

type GameEntryRequest_RequestType int32

const (
	GameEntryRequest_ADD        GameEntryRequest_RequestType = 0
	GameEntryRequest_ACTIVATE   GameEntryRequest_RequestType = 1
	GameEntryRequest_DEACTIVATE GameEntryRequest_RequestType = 2
	GameEntryRequest_SETTINGS   GameEntryRequest_RequestType = 3
	GameEntryRequest_INDEX      GameEntryRequest_RequestType = 4
)

var GameEntryRequest_RequestType_name = map[int32]string{
	0: "ADD",
	1: "ACTIVATE",
	2: "DEACTIVATE",
	3: "SETTINGS",
	4: "INDEX",
}
var GameEntryRequest_RequestType_value = map[string]int32{
	"ADD":        0,
	"ACTIVATE":   1,
	"DEACTIVATE": 2,
	"SETTINGS":   3,
	"INDEX":      4,
}

func (x GameEntryRequest_RequestType) String() string {
	return proto.EnumName(GameEntryRequest_RequestType_name, int32(x))
}
func (GameEntryRequest_RequestType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{7, 0}
}

type ListGamesRequest_InnerState int32

const (
	ListGamesRequest_ANY         ListGamesRequest_InnerState = 0
	ListGamesRequest_CREATED     ListGamesRequest_InnerState = 1
	ListGamesRequest_DEVELOPMENT ListGamesRequest_InnerState = 2
	ListGamesRequest_WAITING     ListGamesRequest_InnerState = 3
	ListGamesRequest_REJECTED    ListGamesRequest_InnerState = 4
	ListGamesRequest_VALIDATED   ListGamesRequest_InnerState = 5
	ListGamesRequest_PRODUCTION  ListGamesRequest_InnerState = 6
)

var ListGamesRequest_InnerState_name = map[int32]string{
	0: "ANY",
	1: "CREATED",
	2: "DEVELOPMENT",
	3: "WAITING",
	4: "REJECTED",
	5: "VALIDATED",
	6: "PRODUCTION",
}
var ListGamesRequest_InnerState_value = map[string]int32{
	"ANY":         0,
	"CREATED":     1,
	"DEVELOPMENT": 2,
	"WAITING":     3,
	"REJECTED":    4,
	"VALIDATED":   5,
	"PRODUCTION":  6,
}

func (x ListGamesRequest_InnerState) String() string {
	return proto.EnumName(ListGamesRequest_InnerState_name, int32(x))
}
func (ListGamesRequest_InnerState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{12, 0}
}

type GetProfileRequest struct {
	Id    string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Email string `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty"`
}

func (m *GetProfileRequest) Reset()                    { *m = GetProfileRequest{} }
func (m *GetProfileRequest) String() string            { return proto.CompactTextString(m) }
func (*GetProfileRequest) ProtoMessage()               {}
func (*GetProfileRequest) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{0} }

type GetChildRequest struct {
	ChildId string `protobuf:"bytes,1,opt,name=child_id,json=childId,proto3" json:"child_id,omitempty"`
}

func (m *GetChildRequest) Reset()                    { *m = GetChildRequest{} }
func (m *GetChildRequest) String() string            { return proto.CompactTextString(m) }
func (*GetChildRequest) ProtoMessage()               {}
func (*GetChildRequest) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{1} }

type GetChildrenFromProfileRequest struct {
	ProfileId string `protobuf:"bytes,1,opt,name=profile_id,json=profileId,proto3" json:"profile_id,omitempty"`
}

func (m *GetChildrenFromProfileRequest) Reset()         { *m = GetChildrenFromProfileRequest{} }
func (m *GetChildrenFromProfileRequest) String() string { return proto.CompactTextString(m) }
func (*GetChildrenFromProfileRequest) ProtoMessage()    {}
func (*GetChildrenFromProfileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{2}
}

type ChangeChildActivationRequest struct {
	ChildId string `protobuf:"bytes,1,opt,name=child_id,json=childId,proto3" json:"child_id,omitempty"`
	Active  bool   `protobuf:"varint,2,opt,name=active,proto3" json:"active,omitempty"`
}

func (m *ChangeChildActivationRequest) Reset()         { *m = ChangeChildActivationRequest{} }
func (m *ChangeChildActivationRequest) String() string { return proto.CompactTextString(m) }
func (*ChangeChildActivationRequest) ProtoMessage()    {}
func (*ChangeChildActivationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{3}
}

type GetChildrenFromProfileResponse struct {
	Children []*Child `protobuf:"bytes,1,rep,name=children" json:"children,omitempty"`
}

func (m *GetChildrenFromProfileResponse) Reset()         { *m = GetChildrenFromProfileResponse{} }
func (m *GetChildrenFromProfileResponse) String() string { return proto.CompactTextString(m) }
func (*GetChildrenFromProfileResponse) ProtoMessage()    {}
func (*GetChildrenFromProfileResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{4}
}

type GetGameReleaseRequest struct {
	GameId  string              `protobuf:"bytes,1,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	Version string              `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	State   RequestReleaseState `protobuf:"varint,3,opt,name=state,proto3,enum=apipb.RequestReleaseState" json:"state,omitempty"`
}

func (m *GetGameReleaseRequest) Reset()                    { *m = GetGameReleaseRequest{} }
func (m *GetGameReleaseRequest) String() string            { return proto.CompactTextString(m) }
func (*GetGameReleaseRequest) ProtoMessage()               {}
func (*GetGameReleaseRequest) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{5} }

type SoundEnableRequest struct {
	ChildId   string `protobuf:"bytes,1,opt,name=child_id,json=childId,proto3" json:"child_id,omitempty"`
	ProfileId string `protobuf:"bytes,2,opt,name=profile_id,json=profileId,proto3" json:"profile_id,omitempty"`
	Enable    bool   `protobuf:"varint,3,opt,name=enable,proto3" json:"enable,omitempty"`
}

func (m *SoundEnableRequest) Reset()                    { *m = SoundEnableRequest{} }
func (m *SoundEnableRequest) String() string            { return proto.CompactTextString(m) }
func (*SoundEnableRequest) ProtoMessage()               {}
func (*SoundEnableRequest) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{6} }

type GameEntryRequest struct {
	ChildId  string                       `protobuf:"bytes,1,opt,name=child_id,json=childId,proto3" json:"child_id,omitempty"`
	GameId   string                       `protobuf:"bytes,2,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	Type     GameEntryRequest_RequestType `protobuf:"varint,3,opt,name=type,proto3,enum=apipb.GameEntryRequest_RequestType" json:"type,omitempty"`
	Settings []byte                       `protobuf:"bytes,4,opt,name=settings,proto3" json:"settings,omitempty"`
	Index    int32                        `protobuf:"varint,5,opt,name=index,proto3" json:"index,omitempty"`
}

func (m *GameEntryRequest) Reset()                    { *m = GameEntryRequest{} }
func (m *GameEntryRequest) String() string            { return proto.CompactTextString(m) }
func (*GameEntryRequest) ProtoMessage()               {}
func (*GameEntryRequest) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{7} }

type PublishResponse struct {
	Type    int32        `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Message string       `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Token   *UploadToken `protobuf:"bytes,3,opt,name=token" json:"token,omitempty"`
}

func (m *PublishResponse) Reset()                    { *m = PublishResponse{} }
func (m *PublishResponse) String() string            { return proto.CompactTextString(m) }
func (*PublishResponse) ProtoMessage()               {}
func (*PublishResponse) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{8} }

type ValidateRequest struct {
	GameId      string       `protobuf:"bytes,1,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	GameVersion string       `protobuf:"bytes,2,opt,name=game_version,json=gameVersion,proto3" json:"game_version,omitempty"`
	NewState    ReleaseState `protobuf:"varint,3,opt,name=new_state,json=newState,proto3,enum=apipb.ReleaseState" json:"new_state,omitempty"`
}

func (m *ValidateRequest) Reset()                    { *m = ValidateRequest{} }
func (m *ValidateRequest) String() string            { return proto.CompactTextString(m) }
func (*ValidateRequest) ProtoMessage()               {}
func (*ValidateRequest) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{9} }

type UpdateIndecesRequest struct {
	ProfileId string   `protobuf:"bytes,1,opt,name=profile_id,json=profileId,proto3" json:"profile_id,omitempty"`
	ChildId   string   `protobuf:"bytes,2,opt,name=child_id,json=childId,proto3" json:"child_id,omitempty"`
	GameIds   []string `protobuf:"bytes,3,rep,name=game_ids,json=gameIds" json:"game_ids,omitempty"`
}

func (m *UpdateIndecesRequest) Reset()                    { *m = UpdateIndecesRequest{} }
func (m *UpdateIndecesRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateIndecesRequest) ProtoMessage()               {}
func (*UpdateIndecesRequest) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{10} }

// Get game by game_id or unique_name
type GetGameRequest struct {
	UniqueName string `protobuf:"bytes,1,opt,name=unique_name,json=uniqueName,proto3" json:"unique_name,omitempty"`
	GameId     string `protobuf:"bytes,2,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
}

func (m *GetGameRequest) Reset()                    { *m = GetGameRequest{} }
func (m *GetGameRequest) String() string            { return proto.CompactTextString(m) }
func (*GetGameRequest) ProtoMessage()               {}
func (*GetGameRequest) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{11} }

type ListGamesRequest struct {
	ReleaseState ListGamesRequest_InnerState `protobuf:"varint,1,opt,name=release_state,json=releaseState,proto3,enum=apipb.ListGamesRequest_InnerState" json:"release_state,omitempty"`
	Limit        int32                       `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
	Offset       int32                       `protobuf:"varint,3,opt,name=offset,proto3" json:"offset,omitempty"`
	Language     string                      `protobuf:"bytes,4,opt,name=language,proto3" json:"language,omitempty"`
}

func (m *ListGamesRequest) Reset()                    { *m = ListGamesRequest{} }
func (m *ListGamesRequest) String() string            { return proto.CompactTextString(m) }
func (*ListGamesRequest) ProtoMessage()               {}
func (*ListGamesRequest) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{12} }

type ListItem struct {
	GameId            string       `protobuf:"bytes,1,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	UniqueName        string       `protobuf:"bytes,2,opt,name=unique_name,json=uniqueName,proto3" json:"unique_name,omitempty"`
	LatestVersion     string       `protobuf:"bytes,3,opt,name=latest_version,json=latestVersion,proto3" json:"latest_version,omitempty"`
	LatestState       ReleaseState `protobuf:"varint,4,opt,name=latest_state,json=latestState,proto3,enum=apipb.ReleaseState" json:"latest_state,omitempty"`
	ProductionVersion string       `protobuf:"bytes,5,opt,name=production_version,json=productionVersion,proto3" json:"production_version,omitempty"`
	Storage           string       `protobuf:"bytes,6,opt,name=storage,proto3" json:"storage,omitempty"`
	ArchiveFormat     string       `protobuf:"bytes,7,opt,name=archive_format,json=archiveFormat,proto3" json:"archive_format,omitempty"`
	ReleasedAt        int64        `protobuf:"varint,8,opt,name=released_at,json=releasedAt,proto3" json:"released_at,omitempty"`
	Languages         []string     `protobuf:"bytes,9,rep,name=languages" json:"languages,omitempty"`
}

func (m *ListItem) Reset()                    { *m = ListItem{} }
func (m *ListItem) String() string            { return proto.CompactTextString(m) }
func (*ListItem) ProtoMessage()               {}
func (*ListItem) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{13} }

type ListItemWithTests struct {
	GameId         string                         `protobuf:"bytes,1,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	UniqueName     string                         `protobuf:"bytes,2,opt,name=unique_name,json=uniqueName,proto3" json:"unique_name,omitempty"`
	TestingVersion int32                          `protobuf:"varint,3,opt,name=testing_version,json=testingVersion,proto3" json:"testing_version,omitempty"`
	Groups         []*ListItemWithTests_TestGroup `protobuf:"bytes,4,rep,name=groups" json:"groups,omitempty"`
}

func (m *ListItemWithTests) Reset()                    { *m = ListItemWithTests{} }
func (m *ListItemWithTests) String() string            { return proto.CompactTextString(m) }
func (*ListItemWithTests) ProtoMessage()               {}
func (*ListItemWithTests) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{14} }

type ListItemWithTests_TestGroup struct {
	Name              string       `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Weight            int32        `protobuf:"varint,2,opt,name=weight,proto3" json:"weight,omitempty"`
	LatestVersion     string       `protobuf:"bytes,3,opt,name=latest_version,json=latestVersion,proto3" json:"latest_version,omitempty"`
	LatestState       ReleaseState `protobuf:"varint,4,opt,name=latest_state,json=latestState,proto3,enum=apipb.ReleaseState" json:"latest_state,omitempty"`
	ProductionVersion string       `protobuf:"bytes,5,opt,name=production_version,json=productionVersion,proto3" json:"production_version,omitempty"`
	Storage           string       `protobuf:"bytes,6,opt,name=storage,proto3" json:"storage,omitempty"`
	ArchiveFormat     string       `protobuf:"bytes,7,opt,name=archive_format,json=archiveFormat,proto3" json:"archive_format,omitempty"`
	ReleasedAt        int64        `protobuf:"varint,8,opt,name=released_at,json=releasedAt,proto3" json:"released_at,omitempty"`
	Languages         []string     `protobuf:"bytes,9,rep,name=languages" json:"languages,omitempty"`
}

func (m *ListItemWithTests_TestGroup) Reset()         { *m = ListItemWithTests_TestGroup{} }
func (m *ListItemWithTests_TestGroup) String() string { return proto.CompactTextString(m) }
func (*ListItemWithTests_TestGroup) ProtoMessage()    {}
func (*ListItemWithTests_TestGroup) Descriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{14, 0}
}

type GetLatestVersionsRequest struct {
	State   RequestReleaseState `protobuf:"varint,1,opt,name=state,proto3,enum=apipb.RequestReleaseState" json:"state,omitempty"`
	GameIds []string            `protobuf:"bytes,2,rep,name=game_ids,json=gameIds" json:"game_ids,omitempty"`
}

func (m *GetLatestVersionsRequest) Reset()         { *m = GetLatestVersionsRequest{} }
func (m *GetLatestVersionsRequest) String() string { return proto.CompactTextString(m) }
func (*GetLatestVersionsRequest) ProtoMessage()    {}
func (*GetLatestVersionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{15}
}

type GameAndVersion struct {
	GameId     string `protobuf:"bytes,1,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	Version    string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	TarballUrl string `protobuf:"bytes,3,opt,name=tarball_url,json=tarballUrl,proto3" json:"tarball_url,omitempty"`
}

func (m *GameAndVersion) Reset()                    { *m = GameAndVersion{} }
func (m *GameAndVersion) String() string            { return proto.CompactTextString(m) }
func (*GameAndVersion) ProtoMessage()               {}
func (*GameAndVersion) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{16} }

type GameVersionsResponse struct {
	Results []*GameAndVersion `protobuf:"bytes,1,rep,name=results" json:"results,omitempty"`
}

func (m *GameVersionsResponse) Reset()                    { *m = GameVersionsResponse{} }
func (m *GameVersionsResponse) String() string            { return proto.CompactTextString(m) }
func (*GameVersionsResponse) ProtoMessage()               {}
func (*GameVersionsResponse) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{17} }

// Search Service
type IndexRequest struct {
}

func (m *IndexRequest) Reset()                    { *m = IndexRequest{} }
func (m *IndexRequest) String() string            { return proto.CompactTextString(m) }
func (*IndexRequest) ProtoMessage()               {}
func (*IndexRequest) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{18} }

type SearchResult struct {
	GameId string  `protobuf:"bytes,1,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	Score  float64 `protobuf:"fixed64,2,opt,name=score,proto3" json:"score,omitempty"`
}

func (m *SearchResult) Reset()                    { *m = SearchResult{} }
func (m *SearchResult) String() string            { return proto.CompactTextString(m) }
func (*SearchResult) ProtoMessage()               {}
func (*SearchResult) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{19} }

type SearchRequest struct {
	Query string              `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	State RequestReleaseState `protobuf:"varint,2,opt,name=state,proto3,enum=apipb.RequestReleaseState" json:"state,omitempty"`
}

func (m *SearchRequest) Reset()                    { *m = SearchRequest{} }
func (m *SearchRequest) String() string            { return proto.CompactTextString(m) }
func (*SearchRequest) ProtoMessage()               {}
func (*SearchRequest) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{20} }

type SearchResponse struct {
	Type    int32           `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Results []*SearchResult `protobuf:"bytes,2,rep,name=results" json:"results,omitempty"`
}

func (m *SearchResponse) Reset()                    { *m = SearchResponse{} }
func (m *SearchResponse) String() string            { return proto.CompactTextString(m) }
func (*SearchResponse) ProtoMessage()               {}
func (*SearchResponse) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{21} }

// Common
type Response struct {
	Type    int32  `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *Response) Reset()                    { *m = Response{} }
func (m *Response) String() string            { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()               {}
func (*Response) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{22} }

// A label selector requirement is a selector that contains values, a key, and an operator
// that relates the key and values.
type LabelSelectorRequirement struct {
	// key is the label key that the selector applies to.
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
	Operator LabelSelectorOperator `protobuf:"varint,2,opt,name=operator,proto3,enum=apipb.LabelSelectorOperator" json:"operator,omitempty"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. If the operator is Gt or Lt, the values
	// array must have a single element, which will be interpreted as an integer.
	Values []string `protobuf:"bytes,3,rep,name=values" json:"values,omitempty"`
}

func (m *LabelSelectorRequirement) Reset()         { *m = LabelSelectorRequirement{} }
func (m *LabelSelectorRequirement) String() string { return proto.CompactTextString(m) }
func (*LabelSelectorRequirement) ProtoMessage()    {}
func (*LabelSelectorRequirement) Descriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{23}
}

// An empty label selector term matches all objects. A null label selector term
// matches no objects.
type LabelSelectorTerm struct {
	// expressions is a list of label selector requirements. The requirements are ANDed.
	Expressions []*LabelSelectorRequirement `protobuf:"bytes,1,rep,name=expressions" json:"expressions,omitempty"`
}

func (m *LabelSelectorTerm) Reset()                    { *m = LabelSelectorTerm{} }
func (m *LabelSelectorTerm) String() string            { return proto.CompactTextString(m) }
func (*LabelSelectorTerm) ProtoMessage()               {}
func (*LabelSelectorTerm) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{24} }

// A label selector represents the union of the results of one or more label queries
// over a set of labels; that is, it represents the OR of the selectors represented
// by the labelSelectorTerms.
type LabelSelector struct {
	// terms is a list of label selector terms. The terms are ORed.
	Terms []*LabelSelectorTerm `protobuf:"bytes,1,rep,name=terms" json:"terms,omitempty"`
}

func (m *LabelSelector) Reset()                    { *m = LabelSelector{} }
func (m *LabelSelector) String() string            { return proto.CompactTextString(m) }
func (*LabelSelector) ProtoMessage()               {}
func (*LabelSelector) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{25} }

func init() {
	proto.RegisterType((*GetProfileRequest)(nil), "apipb.GetProfileRequest")
	proto.RegisterType((*GetChildRequest)(nil), "apipb.GetChildRequest")
	proto.RegisterType((*GetChildrenFromProfileRequest)(nil), "apipb.GetChildrenFromProfileRequest")
	proto.RegisterType((*ChangeChildActivationRequest)(nil), "apipb.ChangeChildActivationRequest")
	proto.RegisterType((*GetChildrenFromProfileResponse)(nil), "apipb.GetChildrenFromProfileResponse")
	proto.RegisterType((*GetGameReleaseRequest)(nil), "apipb.GetGameReleaseRequest")
	proto.RegisterType((*SoundEnableRequest)(nil), "apipb.SoundEnableRequest")
	proto.RegisterType((*GameEntryRequest)(nil), "apipb.GameEntryRequest")
	proto.RegisterType((*PublishResponse)(nil), "apipb.PublishResponse")
	proto.RegisterType((*ValidateRequest)(nil), "apipb.ValidateRequest")
	proto.RegisterType((*UpdateIndecesRequest)(nil), "apipb.UpdateIndecesRequest")
	proto.RegisterType((*GetGameRequest)(nil), "apipb.GetGameRequest")
	proto.RegisterType((*ListGamesRequest)(nil), "apipb.ListGamesRequest")
	proto.RegisterType((*ListItem)(nil), "apipb.ListItem")
	proto.RegisterType((*ListItemWithTests)(nil), "apipb.ListItemWithTests")
	proto.RegisterType((*ListItemWithTests_TestGroup)(nil), "apipb.ListItemWithTests.TestGroup")
	proto.RegisterType((*GetLatestVersionsRequest)(nil), "apipb.GetLatestVersionsRequest")
	proto.RegisterType((*GameAndVersion)(nil), "apipb.GameAndVersion")
	proto.RegisterType((*GameVersionsResponse)(nil), "apipb.GameVersionsResponse")
	proto.RegisterType((*IndexRequest)(nil), "apipb.IndexRequest")
	proto.RegisterType((*SearchResult)(nil), "apipb.SearchResult")
	proto.RegisterType((*SearchRequest)(nil), "apipb.SearchRequest")
	proto.RegisterType((*SearchResponse)(nil), "apipb.SearchResponse")
	proto.RegisterType((*Response)(nil), "apipb.Response")
	proto.RegisterType((*LabelSelectorRequirement)(nil), "apipb.LabelSelectorRequirement")
	proto.RegisterType((*LabelSelectorTerm)(nil), "apipb.LabelSelectorTerm")
	proto.RegisterType((*LabelSelector)(nil), "apipb.LabelSelector")
	proto.RegisterEnum("apipb.RequestReleaseState", RequestReleaseState_name, RequestReleaseState_value)
	proto.RegisterEnum("apipb.LabelSelectorOperator", LabelSelectorOperator_name, LabelSelectorOperator_value)
	proto.RegisterEnum("apipb.GameEntryRequest_RequestType", GameEntryRequest_RequestType_name, GameEntryRequest_RequestType_value)
	proto.RegisterEnum("apipb.ListGamesRequest_InnerState", ListGamesRequest_InnerState_name, ListGamesRequest_InnerState_value)
}
func (m *GetProfileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetProfileRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	return i, nil
}

func (m *GetChildRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetChildRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChildId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ChildId)))
		i += copy(dAtA[i:], m.ChildId)
	}
	return i, nil
}

func (m *GetChildrenFromProfileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetChildrenFromProfileRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProfileId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ProfileId)))
		i += copy(dAtA[i:], m.ProfileId)
	}
	return i, nil
}

func (m *ChangeChildActivationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangeChildActivationRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChildId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ChildId)))
		i += copy(dAtA[i:], m.ChildId)
	}
	if m.Active {
		dAtA[i] = 0x10
		i++
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GetChildrenFromProfileResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetChildrenFromProfileResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Children) > 0 {
		for _, msg := range m.Children {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetGameReleaseRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetGameReleaseRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GameId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.GameId)))
		i += copy(dAtA[i:], m.GameId)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if m.State != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.State))
	}
	return i, nil
}

func (m *SoundEnableRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SoundEnableRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChildId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ChildId)))
		i += copy(dAtA[i:], m.ChildId)
	}
	if len(m.ProfileId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ProfileId)))
		i += copy(dAtA[i:], m.ProfileId)
	}
	if m.Enable {
		dAtA[i] = 0x18
		i++
		if m.Enable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GameEntryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameEntryRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChildId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ChildId)))
		i += copy(dAtA[i:], m.ChildId)
	}
	if len(m.GameId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.GameId)))
		i += copy(dAtA[i:], m.GameId)
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Type))
	}
	if len(m.Settings) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Settings)))
		i += copy(dAtA[i:], m.Settings)
	}
	if m.Index != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Index))
	}
	return i, nil
}

func (m *PublishResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublishResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Type))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.Token != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Token.Size()))
		n1, err := m.Token.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *ValidateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidateRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GameId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.GameId)))
		i += copy(dAtA[i:], m.GameId)
	}
	if len(m.GameVersion) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.GameVersion)))
		i += copy(dAtA[i:], m.GameVersion)
	}
	if m.NewState != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.NewState))
	}
	return i, nil
}

func (m *UpdateIndecesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateIndecesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProfileId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ProfileId)))
		i += copy(dAtA[i:], m.ProfileId)
	}
	if len(m.ChildId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ChildId)))
		i += copy(dAtA[i:], m.ChildId)
	}
	if len(m.GameIds) > 0 {
		for _, s := range m.GameIds {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *GetGameRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetGameRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UniqueName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.UniqueName)))
		i += copy(dAtA[i:], m.UniqueName)
	}
	if len(m.GameId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.GameId)))
		i += copy(dAtA[i:], m.GameId)
	}
	return i, nil
}

func (m *ListGamesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListGamesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReleaseState != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.ReleaseState))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Limit))
	}
	if m.Offset != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Offset))
	}
	if len(m.Language) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Language)))
		i += copy(dAtA[i:], m.Language)
	}
	return i, nil
}

func (m *ListItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GameId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.GameId)))
		i += copy(dAtA[i:], m.GameId)
	}
	if len(m.UniqueName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.UniqueName)))
		i += copy(dAtA[i:], m.UniqueName)
	}
	if len(m.LatestVersion) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.LatestVersion)))
		i += copy(dAtA[i:], m.LatestVersion)
	}
	if m.LatestState != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.LatestState))
	}
	if len(m.ProductionVersion) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ProductionVersion)))
		i += copy(dAtA[i:], m.ProductionVersion)
	}
	if len(m.Storage) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Storage)))
		i += copy(dAtA[i:], m.Storage)
	}
	if len(m.ArchiveFormat) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ArchiveFormat)))
		i += copy(dAtA[i:], m.ArchiveFormat)
	}
	if m.ReleasedAt != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.ReleasedAt))
	}
	if len(m.Languages) > 0 {
		for _, s := range m.Languages {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *ListItemWithTests) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListItemWithTests) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GameId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.GameId)))
		i += copy(dAtA[i:], m.GameId)
	}
	if len(m.UniqueName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.UniqueName)))
		i += copy(dAtA[i:], m.UniqueName)
	}
	if m.TestingVersion != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.TestingVersion))
	}
	if len(m.Groups) > 0 {
		for _, msg := range m.Groups {
			dAtA[i] = 0x22
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ListItemWithTests_TestGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListItemWithTests_TestGroup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Weight != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Weight))
	}
	if len(m.LatestVersion) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.LatestVersion)))
		i += copy(dAtA[i:], m.LatestVersion)
	}
	if m.LatestState != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.LatestState))
	}
	if len(m.ProductionVersion) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ProductionVersion)))
		i += copy(dAtA[i:], m.ProductionVersion)
	}
	if len(m.Storage) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Storage)))
		i += copy(dAtA[i:], m.Storage)
	}
	if len(m.ArchiveFormat) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ArchiveFormat)))
		i += copy(dAtA[i:], m.ArchiveFormat)
	}
	if m.ReleasedAt != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.ReleasedAt))
	}
	if len(m.Languages) > 0 {
		for _, s := range m.Languages {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *GetLatestVersionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLatestVersionsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.State))
	}
	if len(m.GameIds) > 0 {
		for _, s := range m.GameIds {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *GameAndVersion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameAndVersion) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GameId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.GameId)))
		i += copy(dAtA[i:], m.GameId)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.TarballUrl) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.TarballUrl)))
		i += copy(dAtA[i:], m.TarballUrl)
	}
	return i, nil
}

func (m *GameVersionsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameVersionsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Results) > 0 {
		for _, msg := range m.Results {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *IndexRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SearchResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GameId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.GameId)))
		i += copy(dAtA[i:], m.GameId)
	}
	if m.Score != 0 {
		dAtA[i] = 0x11
		i++
		i = encodeFixed64Messages(dAtA, i, uint64(math.Float64bits(float64(m.Score))))
	}
	return i, nil
}

func (m *SearchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Query) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Query)))
		i += copy(dAtA[i:], m.Query)
	}
	if m.State != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.State))
	}
	return i, nil
}

func (m *SearchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Type))
	}
	if len(m.Results) > 0 {
		for _, msg := range m.Results {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Type))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *LabelSelectorRequirement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabelSelectorRequirement) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Operator != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Operator))
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *LabelSelectorTerm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabelSelectorTerm) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Expressions) > 0 {
		for _, msg := range m.Expressions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *LabelSelector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabelSelector) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Terms) > 0 {
		for _, msg := range m.Terms {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeFixed64Messages(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Messages(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintMessages(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *GetProfileRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *GetChildRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChildId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *GetChildrenFromProfileRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.ProfileId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *ChangeChildActivationRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChildId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Active {
		n += 2
	}
	return n
}

func (m *GetChildrenFromProfileResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *GetGameReleaseRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.GameId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovMessages(uint64(m.State))
	}
	return n
}

func (m *SoundEnableRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChildId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.ProfileId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Enable {
		n += 2
	}
	return n
}

func (m *GameEntryRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChildId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.GameId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovMessages(uint64(m.Type))
	}
	l = len(m.Settings)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovMessages(uint64(m.Index))
	}
	return n
}

func (m *PublishResponse) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMessages(uint64(m.Type))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *ValidateRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.GameId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.GameVersion)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.NewState != 0 {
		n += 1 + sovMessages(uint64(m.NewState))
	}
	return n
}

func (m *UpdateIndecesRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.ProfileId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.ChildId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.GameIds) > 0 {
		for _, s := range m.GameIds {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *GetGameRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.UniqueName)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.GameId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *ListGamesRequest) Size() (n int) {
	var l int
	_ = l
	if m.ReleaseState != 0 {
		n += 1 + sovMessages(uint64(m.ReleaseState))
	}
	if m.Limit != 0 {
		n += 1 + sovMessages(uint64(m.Limit))
	}
	if m.Offset != 0 {
		n += 1 + sovMessages(uint64(m.Offset))
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *ListItem) Size() (n int) {
	var l int
	_ = l
	l = len(m.GameId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.UniqueName)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.LatestVersion)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.LatestState != 0 {
		n += 1 + sovMessages(uint64(m.LatestState))
	}
	l = len(m.ProductionVersion)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Storage)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.ArchiveFormat)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.ReleasedAt != 0 {
		n += 1 + sovMessages(uint64(m.ReleasedAt))
	}
	if len(m.Languages) > 0 {
		for _, s := range m.Languages {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *ListItemWithTests) Size() (n int) {
	var l int
	_ = l
	l = len(m.GameId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.UniqueName)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.TestingVersion != 0 {
		n += 1 + sovMessages(uint64(m.TestingVersion))
	}
	if len(m.Groups) > 0 {
		for _, e := range m.Groups {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *ListItemWithTests_TestGroup) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Weight != 0 {
		n += 1 + sovMessages(uint64(m.Weight))
	}
	l = len(m.LatestVersion)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.LatestState != 0 {
		n += 1 + sovMessages(uint64(m.LatestState))
	}
	l = len(m.ProductionVersion)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Storage)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.ArchiveFormat)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.ReleasedAt != 0 {
		n += 1 + sovMessages(uint64(m.ReleasedAt))
	}
	if len(m.Languages) > 0 {
		for _, s := range m.Languages {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *GetLatestVersionsRequest) Size() (n int) {
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovMessages(uint64(m.State))
	}
	if len(m.GameIds) > 0 {
		for _, s := range m.GameIds {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *GameAndVersion) Size() (n int) {
	var l int
	_ = l
	l = len(m.GameId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.TarballUrl)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *GameVersionsResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *IndexRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *SearchResult) Size() (n int) {
	var l int
	_ = l
	l = len(m.GameId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Score != 0 {
		n += 9
	}
	return n
}

func (m *SearchRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovMessages(uint64(m.State))
	}
	return n
}

func (m *SearchResponse) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMessages(uint64(m.Type))
	}
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *Response) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMessages(uint64(m.Type))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *LabelSelectorRequirement) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Operator != 0 {
		n += 1 + sovMessages(uint64(m.Operator))
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *LabelSelectorTerm) Size() (n int) {
	var l int
	_ = l
	if len(m.Expressions) > 0 {
		for _, e := range m.Expressions {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *LabelSelector) Size() (n int) {
	var l int
	_ = l
	if len(m.Terms) > 0 {
		for _, e := range m.Terms {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func sovMessages(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMessages(x uint64) (n int) {
	return sovMessages(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GetProfileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetProfileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetProfileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetChildRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetChildRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetChildRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChildId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetChildrenFromProfileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetChildrenFromProfileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetChildrenFromProfileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProfileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangeChildActivationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangeChildActivationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangeChildActivationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChildId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetChildrenFromProfileResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetChildrenFromProfileResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetChildrenFromProfileResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &Child{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetGameReleaseRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetGameReleaseRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetGameReleaseRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (RequestReleaseState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SoundEnableRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SoundEnableRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SoundEnableRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChildId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProfileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameEntryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameEntryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameEntryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChildId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (GameEntryRequest_RequestType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Settings", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Settings = append(m.Settings[:0], dAtA[iNdEx:postIndex]...)
			if m.Settings == nil {
				m.Settings = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublishResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublishResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublishResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Token == nil {
				m.Token = &UploadToken{}
			}
			if err := m.Token.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewState", wireType)
			}
			m.NewState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewState |= (ReleaseState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateIndecesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateIndecesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateIndecesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProfileId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChildId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameIds = append(m.GameIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetGameRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetGameRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetGameRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListGamesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListGamesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListGamesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReleaseState", wireType)
			}
			m.ReleaseState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReleaseState |= (ListGamesRequest_InnerState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LatestVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestState", wireType)
			}
			m.LatestState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatestState |= (ReleaseState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductionVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductionVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Storage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Storage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArchiveFormat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ArchiveFormat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReleasedAt", wireType)
			}
			m.ReleasedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReleasedAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Languages", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Languages = append(m.Languages, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListItemWithTests) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListItemWithTests: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListItemWithTests: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestingVersion", wireType)
			}
			m.TestingVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TestingVersion |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, &ListItemWithTests_TestGroup{})
			if err := m.Groups[len(m.Groups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListItemWithTests_TestGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			m.Weight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LatestVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestState", wireType)
			}
			m.LatestState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatestState |= (ReleaseState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductionVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductionVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Storage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Storage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArchiveFormat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ArchiveFormat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReleasedAt", wireType)
			}
			m.ReleasedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReleasedAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Languages", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Languages = append(m.Languages, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLatestVersionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLatestVersionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLatestVersionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (RequestReleaseState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameIds = append(m.GameIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameAndVersion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameAndVersion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameAndVersion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TarballUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TarballUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameVersionsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameVersionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameVersionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, &GameAndVersion{})
			if err := m.Results[len(m.Results)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Score = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (RequestReleaseState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, &SearchResult{})
			if err := m.Results[len(m.Results)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabelSelectorRequirement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabelSelectorRequirement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabelSelectorRequirement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			m.Operator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Operator |= (LabelSelectorOperator(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabelSelectorTerm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabelSelectorTerm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabelSelectorTerm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expressions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expressions = append(m.Expressions, &LabelSelectorRequirement{})
			if err := m.Expressions[len(m.Expressions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabelSelector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabelSelector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabelSelector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Terms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Terms = append(m.Terms, &LabelSelectorTerm{})
			if err := m.Terms[len(m.Terms)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMessages(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMessages
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMessages
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMessages(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMessages = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMessages   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("messages.proto", fileDescriptorMessages) }

var fileDescriptorMessages = []byte{
	// 1418 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xec, 0x57, 0x5f, 0x6f, 0xdb, 0xb6,
	0x16, 0x8f, 0xe4, 0xc8, 0x7f, 0x8e, 0x1d, 0x47, 0x61, 0xd3, 0x7b, 0xd5, 0xa0, 0x4d, 0x73, 0x75,
	0x71, 0x71, 0x8d, 0x62, 0x75, 0x87, 0x0e, 0x58, 0xbb, 0x0d, 0xdb, 0xe0, 0xc5, 0xae, 0xe1, 0xc2,
	0x75, 0x32, 0xd9, 0x49, 0xbb, 0xbd, 0x04, 0xb2, 0xc5, 0xd8, 0x42, 0x25, 0x51, 0x25, 0xe9, 0x34,
	0x01, 0x86, 0x6d, 0x1f, 0x62, 0x0f, 0x7b, 0xde, 0x77, 0x19, 0xd0, 0xc7, 0x61, 0x9f, 0x60, 0xeb,
	0xbe, 0xc5, 0x9e, 0x06, 0x52, 0x94, 0x2c, 0x67, 0xc9, 0x1a, 0x74, 0xaf, 0x7b, 0x49, 0x74, 0x0e,
	0x0f, 0x79, 0xce, 0xef, 0xc7, 0x1f, 0x79, 0x68, 0xa8, 0x87, 0x98, 0x31, 0x77, 0x8a, 0x59, 0x33,
	0xa6, 0x84, 0x13, 0x64, 0xb8, 0xb1, 0x1f, 0x8f, 0xb7, 0x6a, 0x21, 0xf1, 0x70, 0xa0, 0x9c, 0x5b,
	0x77, 0xa7, 0x3e, 0x9f, 0xcd, 0xc7, 0xcd, 0x09, 0x09, 0xef, 0x4d, 0xc9, 0x94, 0xdc, 0x93, 0xee,
	0xf1, 0xfc, 0x58, 0x5a, 0xd2, 0x90, 0x5f, 0x49, 0xb8, 0xfd, 0x01, 0x6c, 0x74, 0x31, 0xdf, 0xa7,
	0xe4, 0xd8, 0x0f, 0xb0, 0x83, 0x5f, 0xcc, 0x31, 0xe3, 0xa8, 0x0e, 0xba, 0xef, 0x59, 0xda, 0x8e,
	0xd6, 0xa8, 0x38, 0xba, 0xef, 0xa1, 0x4d, 0x30, 0x70, 0xe8, 0xfa, 0x81, 0xa5, 0x4b, 0x57, 0x62,
	0xd8, 0xef, 0xc0, 0x7a, 0x17, 0xf3, 0xdd, 0x99, 0x1f, 0x78, 0xe9, 0xc4, 0x1b, 0x50, 0x9e, 0x08,
	0xfb, 0x28, 0x9b, 0x5e, 0x92, 0x76, 0xcf, 0xb3, 0x3f, 0x81, 0x5b, 0x69, 0x34, 0xc5, 0xd1, 0x23,
	0x4a, 0xc2, 0x73, 0x49, 0x6f, 0x01, 0xc4, 0x89, 0x67, 0x31, 0xbb, 0xa2, 0x3c, 0x3d, 0xcf, 0xfe,
	0x1c, 0x6e, 0xee, 0xce, 0xdc, 0x68, 0x8a, 0xe5, 0x12, 0xad, 0x09, 0xf7, 0x4f, 0x5c, 0xee, 0x93,
	0xe8, 0xcd, 0xa9, 0xd1, 0xbf, 0xa0, 0xe8, 0x8a, 0x78, 0x2c, 0xeb, 0x2f, 0x3b, 0xca, 0xb2, 0x1f,
	0xc3, 0xf6, 0x65, 0x25, 0xb1, 0x98, 0x44, 0x0c, 0xa3, 0x86, 0x5a, 0x94, 0xe2, 0xc8, 0xd2, 0x76,
	0x0a, 0x8d, 0xea, 0xfd, 0x5a, 0x53, 0x92, 0xde, 0x4c, 0x60, 0x67, 0xa3, 0xf6, 0x57, 0x70, 0xbd,
	0x8b, 0x79, 0xd7, 0x0d, 0xb1, 0x83, 0x03, 0xec, 0xb2, 0x0c, 0xd6, 0xbf, 0xa1, 0x34, 0x75, 0xc3,
	0x1c, 0xa6, 0xa2, 0x30, 0x7b, 0x1e, 0xb2, 0xa0, 0x74, 0x82, 0x29, 0xf3, 0x49, 0xa4, 0x68, 0x4d,
	0x4d, 0xf4, 0x2e, 0x18, 0x8c, 0xbb, 0x1c, 0x5b, 0x85, 0x1d, 0xad, 0x51, 0xbf, 0xbf, 0xa5, 0x52,
	0xaa, 0x15, 0xd5, 0xfa, 0x43, 0x11, 0xe1, 0x24, 0x81, 0xf6, 0x31, 0xa0, 0x21, 0x99, 0x47, 0x5e,
	0x27, 0x72, 0xc7, 0x0b, 0x46, 0xff, 0x82, 0x92, 0x65, 0xb2, 0xf5, 0x73, 0x64, 0x0b, 0xc6, 0xb0,
	0x5c, 0x4a, 0x96, 0x50, 0x76, 0x94, 0x65, 0x7f, 0xab, 0x83, 0x29, 0x30, 0x76, 0x22, 0x4e, 0xcf,
	0xae, 0x90, 0x26, 0x07, 0x5e, 0x5f, 0x02, 0xff, 0x00, 0x56, 0xf9, 0x59, 0x9c, 0x22, 0xfc, 0xaf,
	0x42, 0x78, 0x7e, 0xe9, 0x14, 0xf2, 0xe8, 0x2c, 0xc6, 0x8e, 0x9c, 0x80, 0xb6, 0xa0, 0xcc, 0x30,
	0xe7, 0x7e, 0x34, 0x65, 0xd6, 0xea, 0x8e, 0xd6, 0xa8, 0x39, 0x99, 0x2d, 0x64, 0xea, 0x47, 0x1e,
	0x3e, 0xb5, 0x8c, 0x1d, 0xad, 0x61, 0x38, 0x89, 0x61, 0x3f, 0x81, 0x6a, 0x6e, 0x19, 0x54, 0x82,
	0x42, 0xab, 0xdd, 0x36, 0x57, 0x50, 0x0d, 0xca, 0xad, 0xdd, 0x51, 0xef, 0xb0, 0x35, 0xea, 0x98,
	0x1a, 0xaa, 0x03, 0xb4, 0x3b, 0x99, 0xad, 0x8b, 0xd1, 0x61, 0x67, 0x34, 0xea, 0x0d, 0xba, 0x43,
	0xb3, 0x80, 0x2a, 0x60, 0xf4, 0x06, 0xed, 0xce, 0x33, 0x73, 0xd5, 0xf6, 0x61, 0x7d, 0x7f, 0x3e,
	0x0e, 0x7c, 0x36, 0xcb, 0x54, 0x82, 0x14, 0x18, 0x4d, 0xa6, 0x4d, 0xea, 0xb4, 0xa0, 0xa4, 0x4e,
	0x6b, 0xba, 0xbb, 0xca, 0x44, 0x0d, 0x30, 0x38, 0x79, 0x8e, 0x23, 0x89, 0xbd, 0x7a, 0x1f, 0x29,
	0xec, 0x07, 0x71, 0x40, 0x5c, 0x6f, 0x24, 0x46, 0x9c, 0x24, 0xc0, 0xfe, 0x06, 0xd6, 0x0f, 0xdd,
	0xc0, 0xf7, 0xc4, 0x46, 0xbf, 0x49, 0x4d, 0xff, 0x81, 0x9a, 0x1c, 0x58, 0x96, 0x54, 0x55, 0xf8,
	0x0e, 0x33, 0x59, 0x55, 0x22, 0xfc, 0xf2, 0x28, 0x2f, 0xad, 0x6b, 0x99, 0xb4, 0x72, 0x9a, 0x2a,
	0x47, 0xf8, 0xa5, 0xfc, 0xb2, 0x9f, 0xc3, 0xe6, 0x41, 0x2c, 0xd2, 0xf7, 0x22, 0x0f, 0x4f, 0x30,
	0xbb, 0xda, 0x51, 0x5d, 0x12, 0x84, 0xbe, 0x2c, 0x88, 0x1b, 0x50, 0x56, 0xf5, 0x33, 0xab, 0xb0,
	0x53, 0x10, 0x43, 0x09, 0x00, 0x66, 0x3f, 0x86, 0x7a, 0x76, 0x82, 0x92, 0x34, 0xb7, 0xa1, 0x3a,
	0x8f, 0xfc, 0x17, 0x73, 0x7c, 0x14, 0xb9, 0x21, 0x56, 0x79, 0x20, 0x71, 0x0d, 0xdc, 0x10, 0x5f,
	0x2a, 0x2f, 0xfb, 0x3b, 0x1d, 0xcc, 0xbe, 0xcf, 0xe4, 0x6a, 0x59, 0xd5, 0x5d, 0x58, 0xa3, 0x09,
	0x4e, 0xc5, 0x81, 0x26, 0x39, 0xb0, 0x15, 0x07, 0xe7, 0xe3, 0x9b, 0xbd, 0x28, 0xc2, 0x34, 0xa1,
	0xa4, 0x46, 0x73, 0x04, 0x09, 0x9d, 0x05, 0x7e, 0xe8, 0x73, 0x99, 0xd4, 0x70, 0x12, 0x43, 0x9c,
	0x19, 0x72, 0x7c, 0xcc, 0x30, 0x97, 0xdc, 0x1a, 0x8e, 0xb2, 0x84, 0x62, 0x03, 0x37, 0x9a, 0xce,
	0x85, 0x14, 0x56, 0x65, 0x95, 0x99, 0x6d, 0x87, 0x00, 0x8b, 0x2c, 0x52, 0x9a, 0x83, 0x2f, 0xcc,
	0x15, 0x54, 0x85, 0xd2, 0xae, 0xd3, 0x69, 0x8d, 0x3a, 0x6d, 0x53, 0x43, 0xeb, 0x50, 0x6d, 0x77,
	0x0e, 0x3b, 0xfd, 0xbd, 0xfd, 0x27, 0x9d, 0xc1, 0xc8, 0xd4, 0xc5, 0xe8, 0xd3, 0x56, 0x4f, 0x48,
	0xd3, 0x2c, 0x08, 0x9d, 0x3a, 0x9d, 0xc7, 0x9d, 0x5d, 0x11, 0xbb, 0x8a, 0xd6, 0xa0, 0x72, 0xd8,
	0xea, 0xf7, 0xda, 0x72, 0xaa, 0x21, 0x44, 0xbd, 0xef, 0xec, 0xb5, 0x0f, 0x76, 0x47, 0xbd, 0xbd,
	0x81, 0x59, 0xb4, 0x7f, 0xd6, 0xa1, 0x2c, 0x60, 0xf6, 0x38, 0x0e, 0x2f, 0x97, 0xd2, 0x39, 0xda,
	0xf5, 0x3f, 0xd1, 0xfe, 0x3f, 0xa8, 0x07, 0x2e, 0xc7, 0x8c, 0x67, 0x6a, 0x2b, 0xc8, 0x98, 0xb5,
	0xc4, 0x9b, 0xea, 0xed, 0x7d, 0xa8, 0xa9, 0xb0, 0x84, 0xee, 0xd5, 0xcb, 0x25, 0x57, 0x4d, 0x02,
	0x13, 0x1a, 0xee, 0x02, 0x8a, 0x29, 0xf1, 0xe6, 0x13, 0x71, 0xbd, 0x67, 0x29, 0x0c, 0x99, 0x62,
	0x63, 0x31, 0x92, 0xa6, 0xb1, 0xa0, 0xc4, 0x38, 0xa1, 0x82, 0xde, 0x62, 0x22, 0x36, 0x65, 0x8a,
	0x3a, 0x5d, 0x3a, 0x99, 0xf9, 0x27, 0xf8, 0xe8, 0x98, 0xd0, 0xd0, 0xe5, 0x56, 0x29, 0xa9, 0x53,
	0x79, 0x1f, 0x49, 0xa7, 0xc0, 0xab, 0xb6, 0xd7, 0x3b, 0x72, 0xb9, 0x55, 0xde, 0xd1, 0x1a, 0x05,
	0x07, 0x52, 0x57, 0x8b, 0xa3, 0x9b, 0x50, 0x49, 0x77, 0x8c, 0x59, 0x15, 0xa9, 0xda, 0x85, 0xc3,
	0xfe, 0xbd, 0x00, 0x1b, 0x29, 0xa9, 0x4f, 0x7d, 0x3e, 0x1b, 0x61, 0xc6, 0xd9, 0xdf, 0x60, 0xf7,
	0xff, 0xb0, 0x2e, 0xb8, 0xf0, 0xa3, 0xe9, 0x12, 0xbd, 0x86, 0x53, 0x57, 0xee, 0x14, 0xf8, 0x87,
	0x50, 0x9c, 0x52, 0x32, 0x8f, 0xc5, 0x45, 0x28, 0x5a, 0x53, 0x5e, 0xc8, 0x4b, 0xc5, 0x34, 0xc5,
	0xdf, 0xae, 0x08, 0x75, 0xd4, 0x8c, 0xad, 0x1f, 0x75, 0xa8, 0x64, 0x5e, 0x71, 0x81, 0xe5, 0x4e,
	0x98, 0xfc, 0x16, 0x72, 0x7e, 0x89, 0xfd, 0xe9, 0x2c, 0x55, 0xb9, 0xb2, 0xfe, 0xd9, 0xfc, 0xa5,
	0xcd, 0x9f, 0x82, 0xd5, 0xc5, 0xbc, 0x9f, 0x87, 0x9e, 0xdd, 0x37, 0x59, 0x1b, 0xd7, 0xae, 0xd8,
	0xc6, 0x97, 0x6e, 0x47, 0x7d, 0xf9, 0x76, 0xf4, 0xa0, 0x2e, 0x2e, 0xa7, 0x56, 0xe4, 0xa5, 0xd0,
	0xdf, 0xe2, 0x61, 0x71, 0x1b, 0xaa, 0xdc, 0xa5, 0x63, 0x37, 0x08, 0x8e, 0xe6, 0x34, 0x50, 0x1b,
	0x07, 0xca, 0x75, 0x40, 0x03, 0xbb, 0x0b, 0x9b, 0xdd, 0x45, 0xc7, 0x60, 0x59, 0x87, 0xbb, 0x07,
	0x25, 0x8a, 0xd9, 0x3c, 0xe0, 0x4c, 0x3d, 0x83, 0xae, 0xe7, 0x3a, 0xf6, 0xa2, 0x26, 0x27, 0x8d,
	0xb2, 0xeb, 0x50, 0x13, 0x3d, 0xe3, 0x54, 0x81, 0xb5, 0x3f, 0x86, 0xda, 0x10, 0x0b, 0xe6, 0x1d,
	0x19, 0x70, 0x79, 0xf1, 0x9b, 0x60, 0xb0, 0x09, 0xa1, 0xc9, 0xc1, 0xd0, 0x9c, 0xc4, 0xb0, 0x9f,
	0xc2, 0x5a, 0x3a, 0x3d, 0xe1, 0x76, 0x13, 0x8c, 0x17, 0x73, 0x4c, 0xcf, 0xd4, 0xec, 0xc4, 0x58,
	0x30, 0xae, 0x5f, 0xf5, 0xe1, 0x34, 0x84, 0x7a, 0x56, 0xd7, 0xe5, 0xcd, 0xfc, 0xee, 0x02, 0xbe,
	0x2e, 0xe1, 0xa7, 0x3a, 0xce, 0x63, 0x5a, 0x80, 0x7f, 0x08, 0xe5, 0xb7, 0x7b, 0x1b, 0xd8, 0x5f,
	0x83, 0xd5, 0x77, 0xc7, 0x38, 0x18, 0xe2, 0x00, 0x4f, 0x38, 0xa1, 0xa2, 0x72, 0x9f, 0xe2, 0x10,
	0x47, 0x1c, 0x99, 0x50, 0x78, 0x8e, 0x53, 0xc0, 0xe2, 0x13, 0x3d, 0x84, 0x32, 0x89, 0x31, 0x75,
	0x39, 0xa1, 0x0a, 0xf1, 0xcd, 0xf4, 0x0a, 0xc8, 0x2f, 0xb2, 0xa7, 0x62, 0x9c, 0x2c, 0x5a, 0x1c,
	0xee, 0x13, 0x37, 0x98, 0xe3, 0xb4, 0x09, 0x2b, 0xcb, 0x3e, 0x84, 0x8d, 0xa5, 0xa9, 0x23, 0x4c,
	0x43, 0xd4, 0x82, 0x2a, 0x3e, 0x8d, 0x29, 0x66, 0x52, 0x13, 0x4a, 0x00, 0xb7, 0x2f, 0xca, 0x94,
	0x2b, 0xd7, 0xc9, 0xcf, 0xb1, 0x3f, 0x85, 0xb5, 0xa5, 0x40, 0xd4, 0x04, 0x83, 0x63, 0x1a, 0xa6,
	0xab, 0x59, 0x17, 0xad, 0x26, 0x92, 0x3b, 0x49, 0xd8, 0x9d, 0x8f, 0xe0, 0xda, 0x05, 0xbb, 0x88,
	0x36, 0xc1, 0x5c, 0x34, 0xb8, 0xa3, 0xe1, 0x48, 0xbc, 0xdd, 0x56, 0x44, 0xdb, 0x6b, 0xf5, 0xfb,
	0x89, 0x39, 0x34, 0xb5, 0x3b, 0xcf, 0xe0, 0xfa, 0x85, 0x84, 0xa0, 0x22, 0xe8, 0xbd, 0xc8, 0x5c,
	0x11, 0xcf, 0xbb, 0x01, 0xe1, 0xbd, 0xc8, 0xd4, 0x10, 0x40, 0xb1, 0x73, 0xea, 0x33, 0xce, 0x4c,
	0x1d, 0x99, 0x50, 0x6b, 0x13, 0xcc, 0x06, 0x84, 0x4b, 0x97, 0x59, 0x10, 0x13, 0xba, 0xdc, 0x5c,
	0x15, 0xff, 0xfb, 0xdc, 0x34, 0x3e, 0x7b, 0xf0, 0xea, 0xd7, 0xed, 0x95, 0x57, 0xaf, 0xb7, 0xb5,
	0x9f, 0x5e, 0x6f, 0x6b, 0xbf, 0xbc, 0xde, 0xd6, 0xbe, 0xff, 0x6d, 0x7b, 0x05, 0xd6, 0x27, 0x24,
	0x6c, 0x12, 0xce, 0xfc, 0x90, 0x34, 0xa7, 0x34, 0x9e, 0xec, 0x6b, 0x5f, 0x96, 0x13, 0x33, 0x1e,
	0xff, 0xa0, 0x17, 0xf6, 0x46, 0xc3, 0x71, 0x51, 0xfe, 0xfa, 0x7a, 0xef, 0x8f, 0x00, 0x00, 0x00,
	0xff, 0xff, 0x6f, 0x1b, 0xa9, 0xf0, 0xd3, 0x0d, 0x00, 0x00,
}
